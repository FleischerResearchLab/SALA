# AUTOGENERATED! DO NOT EDIT! File to edit: clock_plots.ipynb (unless otherwise specified).

__all__ = ['map_mins_to_rads', 'time_print', 'make_clock_plots']

# Cell
def map_mins_to_rads(d_series):
    """Maps a series of minutes to radians for plot making.

    #### Parameters

    d_series: pd.Series
        A series of minute data

    #### Returns

    (as a tuple) list of mins converted to radians, a converted median
    """
    median = d_series.median()
    p25 = d_series.quantile(0.25)
    p75 = d_series.quantile(0.75)

    return ([x/1440.0*2*np.pi for x in np.arange(p25,p75)], median/1440.0*2*np.pi)

# Cell
def time_print(mins: float):
    """Takes a time (minutes) and returns a printable format.

    #### Parameters

    mins: float
        A numeric value representing minutes.

    #### Returns

    A printable format
    """
    h = int(mins / 60.)
    m = int ( (mins - h * 60) )
    if h >= 24.0:
        h -= 24
    return '{:02d}:{:02d}'.format(h,m)

# Cell
def make_clock_plots(timing_data,
                     group_by:str,
                     thresholds: list = [],
                     figsize: tuple = (5, 10),
                     timezone: str = "America/Los_Angeles"):
    """Creates clock plots for a grouping within timing data.

    #### Parameters

    timing_data: pd.DataFrame

        Timing data to use. Must be processed by the analyze_by_person package within SALA
    group_by: str

        String to subset the timing data for
    thresholds: list

        List of light thresholds.
    figsize: tuple

        Desired size of outputted figure
    timezone: str
        Timezone of participant
    """

    sns.set_style("white")

    if not thresholds:
        thresholds = timing_data.Threshold.unique()

    g_cols = sns.color_palette("Set2", 7)
    box_rad = 0.3 / len(thresholds)
    mw = 2 * np.pi / 1440
    box_sep = 1.1

    ng = len(timing_data[group_by].unique())
    f = plt.figure(figsize = figsize)

    # gn = groupname, grp = group

    # IF STATEMENT THE SUNRISE SUNSET TO CHECK FOR TIMEZONE FIRST
    for gn, grp in enumerate(timing_data[group_by].unique()):
        ax = f.add_subplot(ng, 1, gn + 1, projection = "polar")
        tbg = timing_data[timing_data[group_by] == grp]
        tbg["Sunrise"] = tbg["Sunrise"].apply(lambda x: x - pd.to_datetime(x.date())
                                     .tz_localize(tz=timezone)).apply(
                                      lambda x: x.total_seconds() / (60 * 60))
        tbg["Sunset"] = tbg["Sunset"].apply(lambda x: x - pd.to_datetime(x.date())
                                     .tz_localize(tz=timezone)).apply(
                                      lambda x: x.total_seconds() / (60 * 60))
        sunrise = (tbg["Sunrise"]*60).median()
        sunset = (tbg['Sunset']*60).median()

        dark = [x / 1440.0 * 2 * np.pi for x in np.arange(0, sunrise)]
        ax.bar(dark, np.ones_like(dark), width = 0.02, color = [0.42,0.42,0.42], linewidth = 0)
        dark = [x / 1440.0 * 2 * np.pi for x in np.arange(sunset, 1440)]
        ax.bar(dark, np.ones_like(dark), width = 0.02, color = [0.42, 0.42, 0.42], linewidth = 0)

        lli=[]
        lll=[]
        for i, thr in enumerate(thresholds):
            added = False
            tbgt = (
                timing_data[(timing_data[group_by] == grp) & (timing_data["Threshold"] == thr)]
            )
            onset = 4 * 60 + tbgt["Mins to FL from 4AM"]
            offset = 4 * 60 + tbgt["Mins to LL from 4AM"]
            onbox, onmed = map_mins_to_rads(onset)
            offbox, offmed = map_mins_to_rads(offset)
            ll = ax.bar(onbox, np.full(len(onbox), box_rad),
                       width = mw, bottom = 1.0 - (i + 1) * box_rad * box_sep,
                       color = g_cols[i], linewidth = 0, alpha = 1.0)
            _ = ax.bar(onmed, box_rad,
                      width = 0.02, bottom = 1.0 - (i + 1) * box_rad * box_sep,
                      color = [0.2, 0.2, 0.2], linewidth = 0)

            # attempting to deal with low threshold light onset w/o offset issues
            # sometimes present in small datasets
            if (len(ll) > 0):
                lli.append(ll)
                lll.append('{:3d}lx {}-{}'.format(thr, time_print(onset.median()), time_print(offset.median())) )
                added = True
            ll = ax.bar(offbox, np.full(len(offbox), box_rad),
                       width = mw, bottom = 1.0 - (i + 1) * box_rad * box_sep,
                       color = g_cols[i], linewidth = 0, alpha = 1.0)
            _ = ax.bar(offmed, box_rad,
                    width = 0.02, bottom = 1.0 - (i + 1) * box_rad * box_sep,
                    color = [0.2, 0.2, 0.2], linewidth = 0)
            if (len(ll) > 0) and (not added):
                lli.append(ll)
                lll.append('{}lx'.format(thr))

        offset = tbgt['Sleep offset MSLM']
        onset = tbgt['Sleep onset MSLM']
        offbox, offmed = map_mins_to_rads(offset)
        onbox, onmed = map_mins_to_rads(onset)
        p = ax.bar(offbox, np.full(len(offbox), 2 * box_rad),
                  width = mw, bottom = 1.0 - (i + 3) * box_rad * box_sep,
                  color = g_cols[-2], linewidth = 0, alpha = 1.0)
        _ =ax.bar(offmed, 2 * box_rad, width = 0.02,
                  bottom = 1.0 - (i + 3) * box_rad * box_sep,
                  color=[0.2, 0.2, 0.2], linewidth=0)
        ll = ax.bar(onbox, np.full(len(onbox), 2 * box_rad),
                  width = mw, bottom = 1.0 - (i + 3) * box_rad * box_sep,
                  color = g_cols[-2], linewidth = 0, alpha = 1.0)
        _ = ax.bar(onmed, 2 * box_rad,
                  width = 0.02, bottom = 1.0 - (i + 3) * box_rad * box_sep,
                  color = [0.2, 0.2, 0.2], linewidth = 0)
        lli.append(ll)
        lll.append('Sleep {}-{}'.format(time_print(onset.median()), time_print(offset.median())) )

        thetat = np.arange(0,6)*60
        thetalbl = ['00:00','04:00','08:00','12:00','16:00','20:00']
        ax.set_thetagrids(thetat, labels=thetalbl)
        ax.set_theta_direction(-1)
        ax.set_theta_offset(np.pi)

        # less radial ticks
        ax.set_rticks([])
        ax.set_rmax(1.0)
        ax.grid(False)

        # if gn + 1 == ng:
        ax.legend(lli,lll,loc=[1.01,0.01],prop={'family': 'monospace'})

        nuids = len(tbg.UID.unique())
        ndays = len(tbg.Date.unique())
        pdays = len(tbgt[['UID','Date']].drop_duplicates())
        title = "{}={}: {} subjects, {} dates, {} person-days".format(group_by,grp,nuids,ndays,pdays)
        ax.set_title(title, y = 1.02) #loc='center', ha='center', va='bottom')

    plt.subplots_adjust(wspace = 1.2)