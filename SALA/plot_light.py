# AUTOGENERATED! DO NOT EDIT! File to edit: 02_plot_light.ipynb (unless otherwise specified).

__all__ = ['plot_light']

# Cell
def plot_light(d_list, l_list, palette,
               toplot = "mean/sem",
               y_lim = 1200, y_label = "Lux"):

    """ Creates various light plots to aggregate data based on time of day.

    #### Parameters

    d_list: list

        A list of series of light data for plotting.
    l_list: list

        A list of labels corresponding how you'd like each series in d_list to be labeled.
    palette:sns.color_palette

        Seaborn color palette for plots
    toplot: str

        The type of plot you'd like to create. Default is "mean/sem". Other choices are
        "counts", and "quantiles"
    y_limit: int

        Desired default range for y_limit of the outputted plots.
    y_label: str

        Desired label for the y-axis of outputted plots.
    """

    # number of labels and corresponding series must match
    assert ( len(d_list) == len(l_list) )
    dm = []
    dlo = []
    dhi = []
    tinc = 200

    if toplot == "mean/sem":
        for d in d_list:
            dm.append(pd.Series(d.mean()).sort_index())
            tmp = pd.Series(d.sem()).sort_index()
            dlo.append( dm[-1] - tmp )
            dhi.append( dm[-1] + tmp )

    elif toplot == "counts":
        tinc = 5000
        toplot = ''
        y_label = "Number of samples "
        func = lambda x: x.max().to_frame().shape[0]
        y_choices = [func(x) for x in d_list]
        y_lim = np.max(y_choices) * 10
        for d in d_list:
            dm.append( d.count().sort_index() )
            dlo.append( dm[-1] )
            dhi.append( dm[-1] )

    elif toplot=="quantiles":
        for d in d_list:
            dm.append( d.median().sort_index() )
            dlo.append( d.quantile(0.25).sort_index() )
            dhi.append( d.quantile(0.75).sort_index() )
    else:
        print("What do you want to plot? Valid options include:")
        print("mean/sem , counts , quantiles")
        return

    plt.figure(figsize=(8,6))
    ax=plt.gca()

    pidx = 0
    for mid, lo, hi, lab in zip(dm,dlo,dhi,l_list):
        cval = mpl.colors.to_hex( palette[pidx] )
        pidx = pidx + 1
        timval = [ pd.Timestamp(av.isoformat()) for av in mid.index.tolist() ]

        vals = pd.DataFrame( mid )
        vals['time']=vals.index.to_series()
        vals['mins']=vals.time.apply(lambda x: x.second/60.0 + x.minute + x.hour*60.0)
        vals['lux-mins']=vals['White Light']*vals['mins']
        v = vals['lux-mins'].dropna().mean()/vals['White Light'].dropna().mean()
        hrs = int(v/1440*24)
        mins = int( (v - hrs*60) )
        tmid = time( hrs, mins)
        print ('{} - cumulative {}*sec: {:e}, center of mass of light exposure: {}'.format(lab,y_label.strip(),mid.sum()*20,tmid))
        lab = lab+'\n{:4.3e} lx*s, COLE {}'.format(mid.sum()*20,tmid)

        ax.plot(timval, mid.values, color=cval, label=lab)
        ax.fill_between(timval, hi.values, lo.values, color=cval, alpha=0.33)

    ax.legend()

    # format the ticks
    tFmt = md.DateFormatter('%H:%M')
    ax.xaxis.set_major_locator(md.HourLocator(byhour=range(0,24,4)))
    ax.xaxis.set_major_formatter(tFmt)
    ax.set_ylim(0,y_lim)
    ax.yaxis.set_ticks(np.arange(tinc,y_lim,tinc))

    ax.grid(True)
    plt.ylabel(y_label + toplot)
    plt.xlabel('Time of day')
